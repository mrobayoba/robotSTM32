/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
// Basic includes
#include "main.h"


/* Definitions */
#define MIN_STACK_SIZE 100 // in words

/* Handlers */
GPIO_Handler_t GPIO_stateLED 		= {0};

// UART comm
USART_Handler_t USART_commSerial 	= {0};
GPIO_Handler_t GPIO_pinTX 			= {0};
GPIO_Handler_t GPIO_pinRX 			= {0};

//
GPIO_Handler_t GPIO_proximityInt 	= {0};
EXTI_Config_t EXTI_proximityInt 	= {0};

// Encoders
GPIO_Handler_t GPIO_encoderR 		= {0}; // PinC1
GPIO_Handler_t GPIO_encoderL 		= {0}; //PinC3

Timer_Handler_t TIM_samplingTimer 	= {0};

encoder_handler_t encoderS_Handler 	= {0}; // Private

// PID
PID_Controller_t PID_Left 			= {0};
PID_Controller_t PID_Right			= {0};

// PWM wheels
GPIO_Handler_t GPIO_pwm_R			= {0}; //
GPIO_Handler_t GPIO_enR 			= {0}; //
GPIO_Handler_t GPIO_inR 			= {0}; //

GPIO_Handler_t GPIO_pwm_L			= {0}; //
GPIO_Handler_t GPIO_enL 			= {0}; //
GPIO_Handler_t GPIO_inL 			= {0}; //

PWM_Handler_t PWM_Right 			= {0}; // RIGHT WHEEL
PWM_Handler_t PWM_Left 				= {0}; // LEFT WHEEL

// A-star
mapHandler_t Map_Handler 			= {0};

// For drive the Oppy_1
uint16_t N_right 				= 0; // Number of steps counted in DELTA_T seconds
uint16_t N_left 				= 0;
float speed_fixed_L 			= 0;
float speed_fixed_R 			= 0;
uint16_t pwmRight 				= 0;
uint16_t pwmLeft 				= 0;

float omega 			= 0; // angular frequency
float S_Right 			= 0; // distance factor: To calculate distance
float	S_Left 			= 0;

float speed 			= 30; // 30mm/s by Default
float N_setpoint 		= 12; // 12 counts on 100ms
float distance 			= 0;
float target 			= 0; // To define a distance/angule target

uint8_t flag_newSpeed 			= RESET;
uint8_t flag_refreshPwm 		= RESET;
uint8_t flag_restart_movement 	= RESET;
uint8_t flag_PID 				= RESET;

// for SPI
//SPI_Handler_t spiTester	= {0};
//GPIO_Handler_t spiMISO	= {0};
//GPIO_Handler_t spiMOSI	= {0};
//GPIO_Handler_t spiSCK	= {0};

//GPIO_Handler_t spiSlavePin = {0};
//
//GPIO_Handler_t spi_extiPin_DataAvailable = {0};
//EXTI_Config_t spi_DataAvailable = {0};

/* Task Handlers */
/* comm tasks*/
TaskHandle_t xTaskHandler_menu = NULL;
TaskHandle_t xTaskHandler_print = NULL;
TaskHandle_t xTaskHandler_comm = NULL;

/* operational tasks */
TaskHandle_t xTaskHandler_blinkyMode = NULL;
TaskHandle_t xTaskHandler_PID_core = NULL;
TaskHandle_t xTaskHandler_Astar = NULL;
TaskHandle_t xTaskHandler_driveOppyTo = NULL;
TaskHandle_t xTaskHandler_squareTest = NULL;

/* Queues Handlers */
/* comm queues */
QueueHandle_t xQueueHandler_print;
QueueHandle_t xQueueHandler_inputData;
QueueHandle_t xQueueHandler_naviList;
//QueueHandle_t xQueueHandler_gyroData;

/* Software timer */
TimerHandle_t xTimerHandler_LED;

/* Binary Semaphore */
//SemaphoreHandle_t xBinSemphrHandler_MoveOneStep;

/* Private Handler */
state_t next_state = sMainMenu;
//gyroHandler_t L3G4200D	= {0};

/* Global Variables */
//uint32_t SystemCoreClock = 16000000; // 16MHz
uint32_t SystemCoreClock = 100000000; // 100MHz

uint8_t commData = {0};
char bufferData[MAX_MESH_SIZE] = {0}; // Max MAX_MESH_SIZE characters

float kIncrement = 0.5;

float correctionFactor = 0.35f;

BaseType_t xReturned; // To check the task status

uint16_t msToBlink = 250;

//float cFactor = 0.0f; // For gyro

/*
 * this size is because when the FIFO is read
 * all the output data registers will be out of it
 */
//int16_t gyroBuffer[GYRO_WATERMARK_VALUE*3] = {0};

const TickType_t xBlockTimeMaxExpected = pdMS_TO_TICKS(1000); // ait in block state max 1s

TickType_t motionDelay = pdMS_TO_TICKS(250); // To wait before a step in driveOppyTo

// For calibration
uint16_t sampling_time = SAMPLING_TIME;
uint16_t squareShape[2] = {3,3}; // Standard size 1.77m

uint8_t flag_print = RESET; // Choose to print encoders counting and set point

// For A_start pathFinder
char auxBufferData[MAX_MESH_SIZE] = {0}; // to hold the map when enter by console
float gridSize = GRID_SIZE; // if not grid size is enter, use GRID_SIZE as default

/* Prototypes */
void initSys(void);

extern void clear_string(char *string);

/* RTOS Prototypes */
extern void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName);

extern void vTask_menu( void * pvParameters );
extern void vTask_print( void * pvParameters );
extern void vTask_comm( void * pvParameters );

extern void vTask_PID_core(void* pvParameters);
extern void vTask_Astar(void* pvParameters);
extern void vTask_driveOppyTo(void* pvParameters); // Pass movement type (for, back, right, left) and distance(angle) to drive the spirit
extern void vTask_squareTest(void* pvParameters);

extern void vTimer_Callback_LED(TimerHandle_t xTimer);
extern void vTimer_Callback_encoderSampling(TimerHandle_t xTimer);

int main(void)
{
	/*
	 * If PLL is needed, configure it first!!
	 */
	pllConfig();

	// FPU Activation

	SCB->CPACR    |= (0xF << 20);

	// Clock counter activation
	DWT->CTRL    |= (1 << 0);

	initSys(); // To configure all peripherals
	oppyStop();

	S_Left = (C_LEFT_WHEEL)/N;//mm per Encoder counts
	S_Right = (C_RIGHT_WHEEL)/N;//mm

	S_Right = (S_Right+S_Left)/2.0f; // Save mean in S_x used in PID task

	/* Create Tasks*/
	// Task menu
	xReturned = xTaskCreate(
	                    vTask_menu,       				/* Function that implements the task. */
	                    "Menu Task",          			/* Text name for the task. */
	                    MIN_STACK_SIZE*3,      			/* Stack size in words, not bytes. Remains 13 words */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_2,	/* Priority at which the task is created. */
	                    &xTaskHandler_menu );      		/* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task print
	xReturned = xTaskCreate(
	                    vTask_print,       				/* Function that implements the task. */
	                    "Print Task",          			/* Text name for the task. */
	                    MIN_STACK_SIZE,      			/* Stack size in words, not bytes. Remains 10 words -50 */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_2,	/* Priority at which the task is created. */
	                    &xTaskHandler_print );      	/* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task command
	xReturned = xTaskCreate(
	                    vTask_comm,       				/* Function that implements the task. */
	                    "Command Task",          		/* Text name for the task. */
	                    MIN_STACK_SIZE*3,      			/* Stack size in words, not bytes. Remains 13 words */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_2,	/* Priority at which the task is created. */
	                    &xTaskHandler_comm );	  		/* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task blinky mode
	xReturned = xTaskCreate(
	                    vTask_blinkyMode,       		/* Function that implements the task. */
	                    "Blinky mode",          		/* Text name for the task. */
	                    MIN_STACK_SIZE-40,      		/* Stack size in words, not bytes. Remains 8 words */
	                    (void*) &msToBlink,    			/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_2,	/* Priority at which the task is created. */
	                    &xTaskHandler_blinkyMode);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task PID robot driver
	xReturned = xTaskCreate(
	                    vTask_PID_core,       			/* Function that implements the task. */
	                    "PID core task",          		/* Text name for the task. */
	                    MIN_STACK_SIZE*3,      			/* Stack size in words, not bytes. Remains 12 words */
	                    (void*) &encoderS_Handler,    	/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_5,	/* Priority at which the task is created. */
	                    &xTaskHandler_PID_core);      	/* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task A-star
	xReturned = xTaskCreate(
	                    vTask_Astar,       				/* Function that implements the task. */
	                    "A-star algorithm",          	/* Text name for the task. */
	                    MIN_STACK_SIZE*10,      		/* Stack size in words, not bytes. Remains 12 words */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_4,	/* Priority at which the task is created. */
	                    &xTaskHandler_Astar);      		/* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task driveOppyTo
	xReturned = xTaskCreate(
	                    vTask_driveOppyTo,       		/* Function that implements the task. */
	                    "Oppy driver task",          	/* Text name for the task. */
	                    MIN_STACK_SIZE*2,      		/* Stack size in words, not bytes. Remains 12 words */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_3,	/* Priority at which the task is created. */
	                    &xTaskHandler_driveOppyTo);     /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task square test
	xReturned = xTaskCreate(
	                    vTask_squareTest,       		/* Function that implements the task. */
	                    "square test",          		/* Text name for the task. */
	                    MIN_STACK_SIZE,      		/* Stack size in words, not bytes. Remains 12 words */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_4,	/* Priority at which the task is created. */
	                    &xTaskHandler_squareTest);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	/* Create Queues */
	// Queue input data
	xQueueHandler_inputData = xQueueCreate(MAX_MESH_SIZE, sizeof(char));
	configASSERT(xQueueHandler_inputData != NULL);
	// Queue print
	xQueueHandler_print = xQueueCreate(10, sizeof(size_t));
	configASSERT(xQueueHandler_print != NULL);

	xQueueHandler_naviList = xQueueCreate(MAX_MESH_SIZE, sizeof(nodeHandler_t*));
	configASSERT(xQueueHandler_print != NULL);

	/* Create software timer */
	xTimerHandler_LED = xTimerCreate("led_timer", pdMS_TO_TICKS(msToBlink), pdTRUE, (void*)(1), (void *) vTimer_Callback_LED);
	xTimerStart(xTimerHandler_LED,portMAX_DELAY);

	/* Create semaphores */

	/* Create mutexes */

	// Start the created tasks running
	vTaskStartScheduler();

    /* Loop forever */
	while(1){

	}
}

/* Task to be created. */

// USART Callback
void usart2_RxCallback(void){
	commData = usart_getRxData();

	BaseType_t xHigherPriorityTaskWoken;
	(void) xHigherPriorityTaskWoken;

	xHigherPriorityTaskWoken = pdFALSE; // No task woken yet

	xReturned = xQueueIsQueueFullFromISR(xQueueHandler_inputData); // Check if the queue is not full yet

	if (xReturned != pdTRUE){
		xQueueSendToBackFromISR(xQueueHandler_inputData,(void *) &commData,NULL);
	} else{
		 // Queue full
		if (commData == '\r'){
			xQueueReceiveFromISR(xQueueHandler_inputData, (void*) &commData,NULL);
			xQueueSendToBackFromISR(xQueueHandler_inputData,(void*) &commData,NULL);
		}
		else{
			commData = '\r';
			xQueueSendToBackFromISR(xQueueHandler_inputData,(void*) &commData,NULL);
		}
	}
	// Send notification to command task
	if(commData == '\r'){
		xTaskNotifyFromISR(xTaskHandler_comm,0,eNoAction,NULL);
//		xSemaphoreGiveFromISR(xBinarySemaphore,&xHigherPriorityTaskWoken);
	}
}

void usart1_RxCallback(void){
	commData = usart_getRxData();

	BaseType_t xHigherPriorityTaskWoken;
	(void) xHigherPriorityTaskWoken;

	xHigherPriorityTaskWoken = pdFALSE; // No task woken yet

	xReturned = xQueueIsQueueFullFromISR(xQueueHandler_inputData); // Check if the queue is not full yet

	if (xReturned != pdTRUE){
		xQueueSendToBackFromISR(xQueueHandler_inputData,(void *) &commData,NULL);
	} else{
		 // Queue full
		if (commData == '\r'){
			xQueueReceiveFromISR(xQueueHandler_inputData, (void*) &commData,NULL);
			xQueueSendToBackFromISR(xQueueHandler_inputData,(void*) &commData,NULL);
		}
		else{
			commData = '\r';
			xQueueSendToBackFromISR(xQueueHandler_inputData,(void*) &commData,NULL);
		}
	}
	// Send notification to command task
	if(commData == '\r'){
		xTaskNotifyFromISR(xTaskHandler_comm,0,eNoAction,NULL);
//		xSemaphoreGiveFromISR(xBinarySemaphore,&xHigherPriorityTaskWoken);
	}
}

// Software timer Callbacks
void vTimer_Callback_LED(TimerHandle_t xTimer){
	gpio_TogglePin(&GPIO_stateLED);

	// This code allows to check remaining stack while a task is execute
//	clear_string(bufferData);
//	portENTER_CRITICAL();
//	UBaseType_t highWaterMark = uxTaskGetStackHighWaterMark(xTaskHandler_squareTest);
//	sprintf(bufferData,"Remaining STACK from : %d\n\r",(uint)highWaterMark);
//	usart_writeMsg(&USART_commSerial, (char *) bufferData);
//	portEXIT_CRITICAL();
//	clear_string(bufferData);
}

// EXTI CallBacks
void callback_ExtInt7(void){ // Proximity Sensor Callback
//	BaseType_t xHigherPriorityTaskWoken;
//
//	xHigherPriorityTaskWoken = pdFALSE; // Comment this!!!
//
//	xTaskNotifyFromISR(xTaskHandler_blinkyMode,0,eNoAction,&xHigherPriorityTaskWoken);
}

// STACK OVERFLOW CALLBACK
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName) {
    // Handle stack overflow, e.g., log the error, reset the system, etc.
	clear_string(bufferData);
	sprintf(bufferData,"Stack Overflow detected in task: %s\n\r",pcTaskName);
	usart_writeMsg(&USART_commSerial, (char *) bufferData);
	clear_string(bufferData);
    taskDISABLE_INTERRUPTS(); // Recommended
    for (;;); // Infinite loop to halt the system
}


/* System initialization */
void initSys(void){

	// Config State LED
	GPIO_stateLED.pGPIOx							= GPIOA;
	GPIO_stateLED.pinConfig.GPIO_PinNumber			= PIN_5;
	GPIO_stateLED.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	GPIO_stateLED.pinConfig.GPIO_PinOutputSpeed		= GPIO_OSPEEDR_MEDIUM;
	GPIO_stateLED.pinConfig.GPIO_PinOutputType		= GPIO_OTYPER_PUSHPULL;
	GPIO_stateLED.pinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_stateLED);
	gpio_WritePin(&GPIO_stateLED, RESET);

	// Sampling Timer  configured in encoderCounting_driver.c


	// Config UART communication
	GPIO_pinTX.pGPIOx							= GPIOA;
	GPIO_pinTX.pinConfig.GPIO_PinNumber			= PIN_2;
//	GPIO_pinTX.pGPIOx							= GPIOA; // USART1
//	GPIO_pinTX.pinConfig.GPIO_PinNumber			= PIN_9; // USART1
	GPIO_pinTX.pinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
	GPIO_pinTX.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEED_HIGH;
	GPIO_pinTX.pinConfig.GPIO_PinAltFunMode		= AF7;
	gpio_Config(&GPIO_pinTX);

	GPIO_pinRX.pGPIOx							= GPIOA;
	GPIO_pinRX.pinConfig.GPIO_PinNumber			= PIN_3;
//	GPIO_pinRX.pGPIOx							= GPIOA; // USART1
//	GPIO_pinRX.pinConfig.GPIO_PinNumber			= PIN_10; // USART1
	GPIO_pinRX.pinConfig.GPIO_PinMode			= GPIO_MODE_ALTFN;
	GPIO_pinRX.pinConfig.GPIO_PinAltFunMode		= AF7;
	gpio_Config(&GPIO_pinRX);

	USART_commSerial.ptrUSARTx							= USART2;
	USART_commSerial.USART_Config.baudrate				= USART_BAUDRATE_115200;
//	USART_commSerial.ptrUSARTx							= USART1;
//	USART_commSerial.USART_Config.baudrate				= USART_BAUDRATE_19200; // For 50MHz APB1 clock USART1
	USART_commSerial.USART_Config.datasize				= USART_DATASIZE_8BIT;
	USART_commSerial.USART_Config.mode					= USART_MODE_RXTX;
	USART_commSerial.USART_Config.parity				= USART_PARITY_NONE;
	USART_commSerial.USART_Config.stopbits				= USART_STOPBIT_1;
	USART_commSerial.USART_Config.enableIntRX			= USART_RX_INTERRUP_ENABLE;
	USART_commSerial.USART_Config.interruptPriority 	= e_PRIORITY_FREERTOS_MIN_PLUS_6;
	usart_Config(&USART_commSerial);
	usart_config_newInterrupt(&USART_commSerial, e_PRIORITY_FREERTOS_MIN_PLUS_6);

	// Config EXTIs
	GPIO_proximityInt.pGPIOx							= GPIOC;
	GPIO_proximityInt.pinConfig.GPIO_PinNumber			= PIN_7;
	GPIO_proximityInt.pinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	GPIO_proximityInt.pinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_proximityInt);

	EXTI_proximityInt.edgeType							= EXTI_FALLING_EDGE;
	EXTI_proximityInt.interruptPriority					= e_PRIORITY_NORMAL_MIN_PLUS_10;
	EXTI_proximityInt.pGPIOHandler						= &GPIO_proximityInt;
	exti_Config(&EXTI_proximityInt);

//	exti_config_newInterrupt(&EXTI_proximityInt, e_PRIORITY_NORMAL_MIN_PLUS_4); DON'T USE IT

	// Encoders

	GPIO_encoderR.pGPIOx								=	GPIOC;
	GPIO_encoderR.pinConfig.GPIO_PinNumber				=	PIN_1;
	GPIO_encoderR.pinConfig.GPIO_PinMode				=	GPIO_MODE_IN;
	GPIO_encoderR.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_encoderR);

	GPIO_encoderL.pGPIOx								=	GPIOC;
	GPIO_encoderL.pinConfig.GPIO_PinNumber				=	PIN_3;
	GPIO_encoderL.pinConfig.GPIO_PinMode				=	GPIO_MODE_IN;
	GPIO_encoderL.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_encoderL);

	/* encoder counter */
	encoderS_Handler.encoderLeft				=	&GPIO_encoderL;
	encoderS_Handler.encoderRight				=	&GPIO_encoderR;
	encoderS_Handler.samplingTimer				=	&TIM_samplingTimer;
	encoderS_Handler.samplingTime				=	SAMPLING_TIME; // ms
	counterConfig(&encoderS_Handler);

	// PWM Wheels
	GPIO_pwm_R.pGPIOx 							=	GPIOA;
	GPIO_pwm_R.pinConfig.GPIO_PinNumber			=	PIN_1;
	GPIO_pwm_R.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
	GPIO_pwm_R.pinConfig.GPIO_PinAltFunMode		=	AF1;
	GPIO_pwm_R.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_pwm_R);

	GPIO_pwm_L.pGPIOx 							=	GPIOA;
	GPIO_pwm_L.pinConfig.GPIO_PinNumber			=	PIN_0;
	GPIO_pwm_L.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
	GPIO_pwm_L.pinConfig.GPIO_PinAltFunMode		=	AF2;
	GPIO_pwm_L.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_pwm_L);

	GPIO_enR.pGPIOx									=	GPIOC;
	GPIO_enR.pinConfig.GPIO_PinNumber				=	PIN_11;
	GPIO_enR.pinConfig.GPIO_PinMode					=	GPIO_MODE_OUT;
	GPIO_enR.pinConfig.GPIO_PinOutputType			=	GPIO_OTYPER_PUSHPULL;
	GPIO_enR.pinConfig.GPIO_PinOutputSpeed			=	GPIO_OSPEEDR_MEDIUM;
	GPIO_enR.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_enR);
	gpio_WritePin(&GPIO_enR, RESET); // ON = RESET, motor derecho

	GPIO_inR.pGPIOx									=	GPIOD;
	GPIO_inR.pinConfig.GPIO_PinNumber				=	PIN_2;
	GPIO_inR.pinConfig.GPIO_PinMode					=	GPIO_MODE_OUT;
	GPIO_inR.pinConfig.GPIO_PinOutputType			=	GPIO_OTYPER_PUSHPULL;
	GPIO_inR.pinConfig.GPIO_PinOutputSpeed			=	GPIO_OSPEEDR_MEDIUM;
	GPIO_inR.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_inR);
	gpio_WritePin(&GPIO_inR, SET); // SET forward// RESET backward

	GPIO_enL.pGPIOx									=	GPIOC;
	GPIO_enL.pinConfig.GPIO_PinNumber				=	PIN_10;
	GPIO_enL.pinConfig.GPIO_PinMode					=	GPIO_MODE_OUT;
	GPIO_enL.pinConfig.GPIO_PinOutputType			=	GPIO_OTYPER_PUSHPULL;
	GPIO_enL.pinConfig.GPIO_PinOutputSpeed			=	GPIO_OSPEEDR_MEDIUM;
	GPIO_enL.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_enL);
	gpio_WritePin(&GPIO_enL, RESET); // ON = RESET, motor izquierdo

	GPIO_inL.pGPIOx									=	GPIOC;
	GPIO_inL.pinConfig.GPIO_PinNumber				=	PIN_12;
	GPIO_inL.pinConfig.GPIO_PinMode					=	GPIO_MODE_OUT;
	GPIO_inL.pinConfig.GPIO_PinOutputType			=	GPIO_OTYPER_PUSHPULL;
	GPIO_inL.pinConfig.GPIO_PinOutputSpeed			=	GPIO_OSPEEDR_MEDIUM;
	GPIO_inL.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&GPIO_inL);
	gpio_WritePin(&GPIO_inL, RESET); // RESET forward// SET backward

	PWM_Right.ptrTIMx				=	TIM2;
	PWM_Right.config.channel		=	PWM_CHANNEL_2;
	PWM_Right.config.periodo		=	1000; 				// [ms/100] {25,50,100} Hz Default = 25Hz (1kHz)
	PWM_Right.config.prescaler		=	100; 				// 1us
	PWM_Right.config.dutyCycle		=	400;				// [duty/1000] Default 20.0%
	PWM_Right.config.outPolarity	=	PWM_POLARITY_LOW; 	// LOW forward // HIGH backward

	pwm_Config(&PWM_Right);
	pwm_star_Signal(&PWM_Right);

	PWM_Left.ptrTIMx				=	TIM5;
	PWM_Left.config.channel			=	PWM_CHANNEL_1;
	PWM_Left.config.periodo			=	1000;				// 500Hz
	PWM_Left.config.prescaler		=	100; 				// 10us
	PWM_Left.config.dutyCycle		=	400;				// 20.0%
	PWM_Left.config.outPolarity		=	PWM_POLARITY_HIGH; 	// HIGH forward // LOW backward

	pwm_Config(&PWM_Left);
	pwm_star_Signal(&PWM_Left);

	/* PID Controller */
	PID_Left.Kp							= 40.0f; 			//1.9 starts in the conversion factor from N to speed
	PID_Left.Ki							= 39.0f; 			//39
	PID_Left.Kd							= 0.2f; 			//0.2
	//	PID_Left.delta_Kp					= 5.0f;

	PID_Left.T							= SAMPLING_TIME/1000; 	// Sampling Time =  10ms
	PID_Left.tau						= 3.6f; 				//just to keep it greater than samplingTime but it can go close to zero or bigger than samplingTime
	PID_Left.limMin						= MIN_PWM;				// N min value
	PID_Left.limMax						= MAX_PWM;				// N max value


	PID_Right.Kp						= 40.0f; 			//2.25 starts in the conversion factor from N to speed
	PID_Right.Ki						= 40.0f; 			//45
	PID_Right.Kd						= 0.2f; 			//0.2
	//	PID_Right.delta_Kp					= 5.0f;

	PID_Right.T							= SAMPLING_TIME/1000; 	// Sampling Time =  10ms
	PID_Right.tau						= TAU; 					//just to keep it greater than samplingTime but it can go close to zero or bigger than samplingTime
	PID_Right.limMin					= MIN_PWM+50;			// N min value
	PID_Right.limMax					= MAX_PWM+50;			// N max value

	/*
	 * configure SPI2
	 */
//	spiSlavePin.pGPIOx							= GPIOB;
//	spiSlavePin.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
//	spiSlavePin.pinConfig.GPIO_PinNumber		= PIN_1;
//	spiSlavePin.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEEDR_MEDIUM;
//	spiSlavePin.pinConfig.GPIO_PinOutputType	= GPIO_OTYPER_PUSHPULL;
//	spiSlavePin.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spiSlavePin);
//	gpio_WritePin(&spiSlavePin, SET); // Starts unselected
//
//	/*config MISO*/
//	spiMISO.pGPIOx								= GPIOB; //A //B
//	spiMISO.pinConfig.GPIO_PinNumber			= PIN_14; //12 //14
//	spiMISO.pinConfig.GPIO_PinMode				= GPIO_MODE_ALTFN;
//	spiMISO.pinConfig.GPIO_PinAltFunMode		= AF5; //6 //5
//	spiMISO.pinConfig.GPIO_PinPuPdControl 		= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spiMISO);
//
//	/* config MOSI*/
//	spiMOSI.pGPIOx								= GPIOB; //B //B
//	spiMOSI.pinConfig.GPIO_PinNumber			= PIN_15; //8 //15
//	spiMOSI.pinConfig.GPIO_PinMode				= GPIO_MODE_ALTFN;
//	spiMOSI.pinConfig.GPIO_PinAltFunMode		= AF5; //6 //5
//	spiMOSI.pinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spiMOSI);
//
//	/* config SCK*/
//	spiSCK.pGPIOx								= GPIOB; //B //B
//	spiSCK.pinConfig.GPIO_PinNumber				= PIN_13; //0 //13
//	spiSCK.pinConfig.GPIO_PinMode				= GPIO_MODE_ALTFN;
//	spiSCK.pinConfig.GPIO_PinAltFunMode			= AF5; //6 //5
//	//	spiSCK.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spiSCK);
//
//	/* config SPIx */
//	spiTester.ptrSPIx							= SPI2; //SPI5 //SPI2
//	spiTester.SPI_slavePin						= spiSlavePin;
//
//	spiTester.SPI_Config.SPI_mode				= SPI_POL_PHA_11;
//	spiTester.SPI_Config.SPI_baudrate			= SPI_BAUDRATE_FPCLK_4; // 12.5MHz for SPI2
//	spiTester.SPI_Config.SPI_dataSize			= SPI_DATASIZE_8_BIT;
//	spiTester.SPI_Config.SPI_fullDuplexEnable	= SPI_FULL_DUPPLEX;
//	spi_config(spiTester);

	/*config data available interrupt*/
//	spi_extiPin_DataAvailable.pGPIOx						= GPIOC;
//	spi_extiPin_DataAvailable.pinConfig.GPIO_PinNumber		= PIN_4;
//	spi_extiPin_DataAvailable.pinConfig.GPIO_PinMode		= GPIO_MODE_IN;
//	spi_extiPin_DataAvailable.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spi_extiPin_DataAvailable);
//
//	spi_DataAvailable.edgeType					= EXTI_RISING_EDGE;
//	spi_DataAvailable.pGPIOHandler				= &spi_extiPin_DataAvailable;
//	spi_DataAvailable.interruptPriority			= e_PRIORITY_NORMAL_MIN_PLUS_3;
//
//	exti_Config(&spi_DataAvailable);
//	exti_config_newInterrupt(&spi_DataAvailable, e_PRIORITY_FREERTOS_MIN_PLUS_5);


	/* Private configurations */

//	L3G4200D.FullScaleSelection					= e_2000DPS; 		// more range less sensibility
//	L3G4200D.HPFcutOffFreq						= e_HPF_3;  		// freq greater than 4Hz
//	L3G4200D.OutputSelection					= SET;				// allows HPF and LPF2
//	L3G4200D.allowDataReady						= RESET; 			// data ready int
//	L3G4200D.axisToEnable						= e_EN_ONLY_Z_AXIS;
//	L3G4200D.bandwidth							= e_BW3; 			//cut off 110Hz
//	L3G4200D.outputDataRate						= e_ODR400;
//	L3G4200D.powerMode							= e_NORMALMODE;
//	L3G4200D.FIFOstreamEnable					= SET;
//
//	L3G4200D.ptrSensorSPI						= &spiTester;
//	L3Gyro_config(&L3G4200D);

//	switch (L3G4200D.FullScaleSelection) {
//		case e_250DPS:
//			cFactor = 8.75;
//			break;
//		case e_500DPS:
//			cFactor = 17.50;
//			break;
//		case e_2000DPS:
//			cFactor = 70.0;
//			break;
//		default:
//			cFactor = 8.75;
//			break;
//	}

}
