/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
// Basic includes
#include "main.h"


/* Definitions */
#define MIN_STACK_SIZE 100
#define STACK_SIZE 150 // in words
#define STACK_SIZE_PRINT 70
#define STACK_SIZE_COMM 100

/* Handlers */
GPIO_Handler_t stateLED = {0};

// UART comm
USART_Handler_t h_commSerial = {0};
GPIO_Handler_t pinTX_h = {0};
GPIO_Handler_t pinRX_h = {0};

// EXTI example COMMENT THIS HANDLERS!!!
GPIO_Handler_t userButton = {0};
EXTI_Config_t extiButton = {0};

// Encoders
GPIO_Handler_t encoderR = {0}; // PinC1
GPIO_Handler_t encoderL = {0}; //PinC3

Timer_Handler_t samplingTimer = {0};

encoder_handler_t encoderS 	= {0}; // Private

// PID
PID_Controller_t pid_Left 			= {0};
PID_Controller_t pid_Right			= {0};

// PWM wheels
GPIO_Handler_t gpio_pwm_R	=	{0}; //
GPIO_Handler_t enR = {0}; //PinA5
GPIO_Handler_t inR = {0}; //PinA5

GPIO_Handler_t gpio_pwm_L	=	{0}; //
GPIO_Handler_t enL = {0}; //PinA5
GPIO_Handler_t inL = {0}; //PinA5

PWM_Handler_t pwm_R = {0}; // RIGHT WHEEL
PWM_Handler_t pwm_L = {0}; // LEFT WHEEL

// A-star
mapHandler_t Map = {0};

// For drive the Oppy_1
uint16_t N_right = 0; // Number of steps counted in DELTA_T seconds
uint16_t N_left = 0;
float speed_fixed_L = 0;
float speed_fixed_R = 0;
uint16_t pwmRight = 0;
uint16_t pwmLeft = 0;

float omega = 0; // angular frequency
float S_Right = 0; // distance factor: To calculate distance
float	S_Left = 0;

float speed = 30; // 30mm/s by Default
float N_setpoint = 12; // 12 counts on 100ms
float distance = 0;
float target = 0; // To define a distance/angule target

uint8_t flag_newSpeed = RESET;
uint8_t flag_refreshPwm = RESET;
uint8_t flag_restart_movement = RESET;
uint8_t flag_PID = RESET;

// for SPI
//SPI_Handler_t spiTester	= {0};
//GPIO_Handler_t spiMISO	= {0};
//GPIO_Handler_t spiMOSI	= {0};
//GPIO_Handler_t spiSCK	= {0};

//GPIO_Handler_t spiSlavePin = {0};
//
//GPIO_Handler_t spi_extiPin_DataAvailable = {0};
//EXTI_Config_t spi_DataAvailable = {0};

//#define FLAG_PUMP_REF 2
//uint8_t flag_REGISTER1 = 0;
//
//if(algo){
//	flags |= 1<<FLAG_PUMP_REF;
//}
//
//if(flags & 1<<FLAG_PUMP_REF){
//
//}

/* Task Handlers */
/* comm tasks*/
TaskHandle_t xTaskHandler_menu = NULL;
TaskHandle_t xTaskHandler_print = NULL;
TaskHandle_t xTaskHandler_comm = NULL;

/* operational tasks */
TaskHandle_t xTaskHandler_blinkyMode = NULL;
TaskHandle_t xTaskHandler_PID_core = NULL;
TaskHandle_t xTaskHandler_Astar = NULL;
TaskHandle_t xTaskHandler_driveOppyTo = NULL;
TaskHandle_t xTaskHandler_squareTest = NULL;

/* Gyroscope */
//TaskHandle_t xTaskHandler_gyroGetID = NULL;
//TaskHandle_t xTaskHandler_gyroGetData = NULL;
/* Queues Handlers */
/* comm queues */
QueueHandle_t xQueueHandler_print;
QueueHandle_t xQueueHandler_inputData;
QueueHandle_t xQueueHandler_naviList;

/* operational queues */
//QueueHandle_t xQueueHandler_gyroData;

/* Software timer */
TimerHandle_t xTimerHandler_LED;
TimerHandle_t xTimerHandler_encoderSampling;

/* Binary Semaphore */
//SemaphoreHandle_t xBinSemphrHandler_MoveOneStep;

/* Private Handler */
state_t next_state = sMainMenu;
//gyroHandler_t L3G4200D	= {0};

/* Global Variables */
//uint32_t SystemCoreClock = 16000000; // 16MHz
uint32_t SystemCoreClock = 100000000; // 100MHz

uint8_t commData = {0};
char bufferData[MAX_MESH_SIZE] = {0}; // Max MAX_MESH_SIZE characters

float kIncrement = 0.5;

float correctionFactor = 0.35f;

BaseType_t xReturned; // To check the task status

uint16_t msToBlink = 250;
//int16_t gyroBuffer[GYRO_WATERMARK_VALUE*3] = {0}; // this size is because when the FIFO is read
// all the output data registers will be

const TickType_t xBlockTimeMaxExpected = pdMS_TO_TICKS(1000); // ait in block state max 1s

TickType_t motionDelay = pdMS_TO_TICKS(250); // To wait before a step in driveOppyTo
//float cFactor =	0; // For Gyro

// For calibration
uint16_t sampling_time = SAMPLING_TIME;
uint16_t squareShape[2] = {3,3}; // Standard size 1.77m

uint8_t flag_print = RESET; // Choose to print encoders counting and set point

// For A_start pathFinder
char auxBufferData[MAX_MESH_SIZE] = {0}; // to hold the map when enter by console
float gridSize = GRID_SIZE; // if not grid size is enter, use GRID_SIZE as default

/* Prototypes */
void initSys(void);

extern void clear_string(char *string);
//extern void oppyStart(void);
//extern void oppyStop(void);

/* RTOS Prototypes */
extern void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName);

extern void vTask_menu( void * pvParameters );
extern void vTask_print( void * pvParameters );
extern void vTask_comm( void * pvParameters );

extern void vTask_PID_core(void* pvParameters);
extern void vTask_Astar(void* pvParameters);
extern void vTask_driveOppyTo(void* pvParameters); // Pass movement type (for, back, right, left) and distance(angle) to drive the spirit
extern void vTask_squareTest(void* pvParameters);

//extern void vTask_gyroGetID(void* pvParameters);
//extern void vTask_gyroGetData(void* pvParameters);

extern void vTimer_Callback_LED(TimerHandle_t xTimer);
extern void vTimer_Callback_encoderSampling(TimerHandle_t xTimer);

int main(void)
{
	/*
	 * If PLL is needed, configure it first!!
	 */
	pllConfig();

	// FPU Activation

	SCB->CPACR    |= (0xF << 20);

	// Clock counter activation
	DWT->CTRL    |= (1 << 0);

	initSys(); // To configure all peripherals
	oppyStop();

	S_Left = (PI*D_LEFT_WHEEL)/N;//mm
	S_Right = (PI*D_RIGHT_WHEEL)/N;//mm

	S_Right = (S_Right+S_Left)/2.0f; // Save mean in S_x used in PID task

	/* Create Tasks*/
	// Task menu
	xReturned = xTaskCreate(
	                    vTask_menu,       				/* Function that implements the task. */
	                    "Menu Task",          			/* Text name for the task. */
	                    MIN_STACK_SIZE*30,      			/* Stack size in words, not bytes. Remains 13 words */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_2,	/* Priority at which the task is created. */
	                    &xTaskHandler_menu );      		/* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task print
	xReturned = xTaskCreate(
	                    vTask_print,       				/* Function that implements the task. */
	                    "Print Task",          			/* Text name for the task. */
	                    MIN_STACK_SIZE,      			/* Stack size in words, not bytes. Remains 10 words -50 */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_2,	/* Priority at which the task is created. */
	                    &xTaskHandler_print );      	/* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task command
	xReturned = xTaskCreate(
	                    vTask_comm,       				/* Function that implements the task. */
	                    "Command Task",          		/* Text name for the task. */
	                    MIN_STACK_SIZE*20,      			/* Stack size in words, not bytes. Remains 13 words */
	                    NULL,    						/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_2,	/* Priority at which the task is created. */
	                    &xTaskHandler_comm );      		/* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task blinky mode
	xReturned = xTaskCreate(
	                    vTask_blinkyMode,       		/* Function that implements the task. */
	                    "Blinky mode",          		/* Text name for the task. */
	                    MIN_STACK_SIZE-40,      			/* Stack size in words, not bytes. Remains 8 words */
	                    (void*) &msToBlink,    			/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_2,	/* Priority at which the task is created. */
	                    &xTaskHandler_blinkyMode);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task print encoders mode
	xReturned = xTaskCreate(
	                    vTask_PID_core,       		/* Function that implements the task. */
	                    "PID core task",          		/* Text name for the task. */
	                    MIN_STACK_SIZE*2,      			/* Stack size in words, not bytes. Remains 12 words */
	                    (void*) &encoderS,    			/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_5,	/* Priority at which the task is created. */
	                    &xTaskHandler_PID_core);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task A-star
	xReturned = xTaskCreate(
	                    vTask_Astar,       		/* Function that implements the task. */
	                    "A-star algorithm",          		/* Text name for the task. */
	                    MIN_STACK_SIZE*30,      			/* Stack size in words, not bytes. Remains 12 words */
	                    NULL,    			/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_4,	/* Priority at which the task is created. */
	                    &xTaskHandler_Astar);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task driveOppyTo
	xReturned = xTaskCreate(
	                    vTask_driveOppyTo,       		/* Function that implements the task. */
	                    "Oppy driver task",          		/* Text name for the task. */
	                    MIN_STACK_SIZE*30,      			/* Stack size in words, not bytes. Remains 12 words */
	                    NULL,    			/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_3,	/* Priority at which the task is created. */
	                    &xTaskHandler_driveOppyTo);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);

	// Task square test
	xReturned = xTaskCreate(
	                    vTask_squareTest,       		/* Function that implements the task. */
	                    "square test",          		/* Text name for the task. */
	                    MIN_STACK_SIZE*30,      			/* Stack size in words, not bytes. Remains 12 words */
	                    NULL,    			/* Parameter passed into the task. */
	                    e_PRIORITY_FREERTOS_MIN_PLUS_4,	/* Priority at which the task is created. */
	                    &xTaskHandler_squareTest);      /* Used to pass out the created task's handle. */
	configASSERT(xReturned == pdPASS);


	// Task gyro get ID SPI
//	xReturned = xTaskCreate(
//						vTask_gyroGetID,        		/* Function that implements the task. */
//	                    "Gyro get ID",          		/* Text name for the task. */
//	                    STACK_SIZE,      				/* Stack size in words, not bytes. */
//	                    NULL,    						/* Parameter passed into the task. */
//	                    e_PRIORITY_FREERTOS_MIN_PLUS_4,	/* Priority at which the task is created. */
//	                    &xTaskHandler_gyroGetID);      	/* Used to pass out the created task's handle. */
//	configASSERT(xReturned == pdPASS);

	// Task gyro get data SPI
//	xReturned = xTaskCreate(
//						vTask_gyroGetData,        		/* Function that implements the task. */
//	                    "Gyro get data",          		/* Text name for the task. */
//	                    STACK_SIZE*5,      				/* Stack size in words, not bytes. */
//	                    gyroBuffer,    						/* Parameter passed into the task. */
//	                    e_PRIORITY_FREERTOS_MIN_PLUS_4,	/* Priority at which the task is created. */
//	                    &xTaskHandler_gyroGetData);      	/* Used to pass out the created task's handle. */
//	configASSERT(xReturned == pdPASS);

	/* Create Queues */
	// Queue input data
	xQueueHandler_inputData = xQueueCreate(MAX_MESH_SIZE, sizeof(char));
	configASSERT(xQueueHandler_inputData != NULL);
	// Queue print
	xQueueHandler_print = xQueueCreate(10, sizeof(size_t));
	configASSERT(xQueueHandler_print != NULL);

	xQueueHandler_naviList = xQueueCreate(MAX_MESH_SIZE, sizeof(nodeHandler_t*));
	configASSERT(xQueueHandler_print != NULL);
	// Queue gyro data
//	xQueueHandler_gyroData = xQueueCreate(30,sizeof(uint8_t));
//	configASSERT(xQueueHandler_gyroData != NULL);
	/* Create software timer */
	xTimerHandler_LED = xTimerCreate("led_timer", pdMS_TO_TICKS(msToBlink), pdTRUE, (void*)(1), (void *) vTimer_Callback_LED);
	xTimerStart(xTimerHandler_LED,portMAX_DELAY);

//	xTimerHandler_encoderSampling = xTimerCreate("encoder_sampling_timer", pdMS_TO_TICKS(80), pdTRUE, (void*)(1), (void *) vTimer_Callback_encoderSampling);
//	xTimerStart(xTimerHandler_encoderSampling,portMAX_DELAY);

	/* Create semaphores */

//	xBinSemphrHandler_MoveOneStep = xSemaphoreCreateBinary();
//	configASSERT(xBinSemphrHandler_MoveOneStep != NULL);

	/* Create mutexes */

	// Start the created tasks running
	vTaskStartScheduler();

    /* Loop forever */
	while(1){

	}
}

/* Task to be created. */

// USART Callback
void usart2_RxCallback(void){
	commData = usart_getRxData();

	BaseType_t xHigherPriorityTaskWoken;
	(void) xHigherPriorityTaskWoken;

	xHigherPriorityTaskWoken = pdFALSE; // No task woken yet

	xReturned = xQueueIsQueueFullFromISR(xQueueHandler_inputData); // Check if the queue is not full yet

	if (xReturned != pdTRUE){
		xQueueSendToBackFromISR(xQueueHandler_inputData,(void *) &commData,NULL);
	} else{
		 // Queue full
		if (commData == '\r'){
			xQueueReceiveFromISR(xQueueHandler_inputData, (void*) &commData,NULL);
			xQueueSendToBackFromISR(xQueueHandler_inputData,(void*) &commData,NULL);
		}
		else{
			commData = '\r';
			xQueueSendToBackFromISR(xQueueHandler_inputData,(void*) &commData,NULL);
		}
	}
	// Send notification to command task
	if(commData == '\r'){
		xTaskNotifyFromISR(xTaskHandler_comm,0,eNoAction,NULL);
//		xSemaphoreGiveFromISR(xBinarySemaphore,&xHigherPriorityTaskWoken);
	}
}

void usart1_RxCallback(void){
	commData = usart_getRxData();

	BaseType_t xHigherPriorityTaskWoken;
	(void) xHigherPriorityTaskWoken;

	xHigherPriorityTaskWoken = pdFALSE; // No task woken yet

	xReturned = xQueueIsQueueFullFromISR(xQueueHandler_inputData); // Check if the queue is not full yet

	if (xReturned != pdTRUE){
		xQueueSendToBackFromISR(xQueueHandler_inputData,(void *) &commData,NULL);
	} else{
		 // Queue full
		if (commData == '\r'){
			xQueueReceiveFromISR(xQueueHandler_inputData, (void*) &commData,NULL);
			xQueueSendToBackFromISR(xQueueHandler_inputData,(void*) &commData,NULL);
		}
		else{
			commData = '\r';
			xQueueSendToBackFromISR(xQueueHandler_inputData,(void*) &commData,NULL);
		}
	}
	// Send notification to command task
	if(commData == '\r'){
		xTaskNotifyFromISR(xTaskHandler_comm,0,eNoAction,NULL);
//		xSemaphoreGiveFromISR(xBinarySemaphore,&xHigherPriorityTaskWoken);
	}
}

// Software timer Callbacks
void vTimer_Callback_LED(TimerHandle_t xTimer){
	gpio_TogglePin(&stateLED);

	// This code allows to check remaining stack while a task is execute
//	clear_string(bufferData);
//	portENTER_CRITICAL();
//	UBaseType_t highWaterMark = uxTaskGetStackHighWaterMark(xTaskHandler_menu);
//	sprintf(bufferData,"Remaining STACK from : %d\n\r",(uint)highWaterMark);
//	usart_writeMsg(&h_commSerial, (char *) bufferData);
//	portEXIT_CRITICAL();
//	clear_string(bufferData);
}

void vTimer_Callback_encoderSampling(TimerHandle_t xTimer){

}

// EXTI CallBacks
//void callback_ExtInt7(void){ // Example callback
//	BaseType_t xHigherPriorityTaskWoken;
//
//	xHigherPriorityTaskWoken = pdFALSE; // Comment this!!!
//
//	traceISR_ENTER(); // To detect the interrupt with SEGGER
//	xTaskNotifyFromISR(xxTaskHandler_blinkyMode,0,eNoAction,&xHigherPriorityTaskWoken);
//	traceISR_EXIT();
//}

// STACK OVERFLOW CALLBACK
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName) {
    // Handle stack overflow, e.g., log the error, reset the system, etc.
	clear_string(bufferData);
	sprintf(bufferData,"Stack Overflow detected in task: %s\n\r",pcTaskName);
	usart_writeMsg(&h_commSerial, (char *) bufferData);
	clear_string(bufferData);
    taskDISABLE_INTERRUPTS();
    for (;;); // Infinite loop to halt the system
}


/* System initialization */
void initSys(void){

	// Config State LED
	stateLED.pGPIOx							= GPIOA;
	stateLED.pinConfig.GPIO_PinNumber		= PIN_5;
	stateLED.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	stateLED.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEEDR_MEDIUM;
	stateLED.pinConfig.GPIO_PinOutputType	= GPIO_OTYPER_PUSHPULL;
	stateLED.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	gpio_Config(&stateLED);
	gpio_WritePin(&stateLED, RESET);

	// Sampling Timer  configured in encoderCounting_driver.c
//	samplingTimer.pTIMx								= TIM3; // 16-bit Timer
//	samplingTimer.TIMx_Config.TIMx_Prescaler		= 10000; // Generates 0.1 ms increments
//	samplingTimer.TIMx_Config.TIMx_Period			= 2500;	// With the prescaler, generates 250ms increments
//	samplingTimer.TIMx_Config.TIMx_mode				= TIMER_UP_COUNTER;
//	samplingTimer.TIMx_Config.TIMx_InterruptEnable	= TIMER_INT_ENABLE;
//
//	/* load the config of the Timer*/
//	timer_Config(&samplingTimer);
//	timer_SetState(&samplingTimer, TIMER_OFF);

	// Config UART communication
//	pinTX_h.pGPIOx								= GPIOA;
//	pinTX_h.pinConfig.GPIO_PinNumber			= PIN_2;
	pinTX_h.pGPIOx								= GPIOA; // USART1
	pinTX_h.pinConfig.GPIO_PinNumber			= PIN_9; // USART1
	pinTX_h.pinConfig.GPIO_PinMode				= GPIO_MODE_ALTFN;
	pinTX_h.pinConfig.GPIO_PinOutputSpeed		= GPIO_OSPEED_HIGH;
	pinTX_h.pinConfig.GPIO_PinAltFunMode		= AF7;
	gpio_Config(&pinTX_h);

//	pinRX_h.pGPIOx								= GPIOA;
//	pinRX_h.pinConfig.GPIO_PinNumber			= PIN_3;
	pinRX_h.pGPIOx								= GPIOA; // USART1
	pinRX_h.pinConfig.GPIO_PinNumber			= PIN_10; // USART1
	pinRX_h.pinConfig.GPIO_PinMode				= GPIO_MODE_ALTFN;
	pinRX_h.pinConfig.GPIO_PinAltFunMode		= AF7;
	gpio_Config(&pinRX_h);

//	h_commSerial.ptrUSARTx						= USART2;
//	h_commSerial.USART_Config.baudrate			= USART_BAUDRATE_115200;
	h_commSerial.ptrUSARTx						= USART1;
	h_commSerial.USART_Config.baudrate			= USART_BAUDRATE_19200; // For 50MHz APB1 clock USART1
	h_commSerial.USART_Config.datasize			= USART_DATASIZE_8BIT;
	h_commSerial.USART_Config.mode				= USART_MODE_RXTX;
	h_commSerial.USART_Config.parity			= USART_PARITY_NONE;
	h_commSerial.USART_Config.stopbits			= USART_STOPBIT_1;
	h_commSerial.USART_Config.enableIntRX		= USART_RX_INTERRUP_ENABLE;
	h_commSerial.USART_Config.interruptPriority = e_PRIORITY_FREERTOS_MIN_PLUS_6;
	usart_Config(&h_commSerial);
	usart_config_newInterrupt(&h_commSerial, e_PRIORITY_FREERTOS_MIN_PLUS_6);

	// Config EXTIs
//	userButton.pGPIOx							= GPIOB;
//	userButton.pinConfig.GPIO_PinNumber			= PIN_7;
//	userButton.pinConfig.GPIO_PinMode			= GPIO_MODE_IN;
//	userButton.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
//	gpio_Config(&userButton);
//
//	extiButton.edgeType							= EXTI_FALLING_EDGE;
//	extiButton.interruptPriority				= e_PRIORITY_NORMAL_MIN_PLUS_10;
//	extiButton.pGPIOHandler						= &userButton;
//	exti_Config(&extiButton);
//	exti_config_newInterrupt(&extiButton, e_PRIORITY_NORMAL_MIN_PLUS_4);

	// Encoders

	encoderR.pGPIOx								=	GPIOC;
	encoderR.pinConfig.GPIO_PinNumber			=	PIN_1;
	encoderR.pinConfig.GPIO_PinMode				=	GPIO_MODE_IN;
	encoderR.pinConfig.GPIO_PinPuPdControl		=	GPIO_PUPDR_NOTHING;
	gpio_Config(&encoderR);

	encoderL.pGPIOx								=	GPIOC;
	encoderL.pinConfig.GPIO_PinNumber			=	PIN_3;
	encoderL.pinConfig.GPIO_PinMode				=	GPIO_MODE_IN;
	encoderL.pinConfig.GPIO_PinPuPdControl		=	GPIO_PUPDR_NOTHING;
	gpio_Config(&encoderL);

	/* encoder counter */
	encoderS.encoderLeft				=	&encoderL;
	encoderS.encoderRight				=	&encoderR;
	encoderS.samplingTimer				=	&samplingTimer;
	encoderS.samplingTime				=	SAMPLING_TIME; // ms
	counterConfig(&encoderS);

	// PWM Wheels
	gpio_pwm_R.pGPIOx 							=	GPIOA;
	gpio_pwm_R.pinConfig.GPIO_PinNumber			=	PIN_1;
	gpio_pwm_R.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
	gpio_pwm_R.pinConfig.GPIO_PinAltFunMode		=	AF1;
	gpio_pwm_R.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
	gpio_Config(&gpio_pwm_R);

	gpio_pwm_L.pGPIOx 							=	GPIOA;
	gpio_pwm_L.pinConfig.GPIO_PinNumber			=	PIN_0;
	gpio_pwm_L.pinConfig.GPIO_PinMode			=	GPIO_MODE_ALTFN;
	gpio_pwm_L.pinConfig.GPIO_PinAltFunMode		=	AF2;
	gpio_pwm_L.pinConfig.GPIO_PinPuPdControl	=	GPIO_PUPDR_NOTHING;
	gpio_Config(&gpio_pwm_L);

	enR.pGPIOx									=	GPIOC;
	enR.pinConfig.GPIO_PinNumber				=	PIN_11;
	enR.pinConfig.GPIO_PinMode					=	GPIO_MODE_OUT;
	enR.pinConfig.GPIO_PinOutputType			=	GPIO_OTYPER_PUSHPULL;
	enR.pinConfig.GPIO_PinOutputSpeed			=	GPIO_OSPEEDR_MEDIUM;
	enR.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&enR);
	gpio_WritePin(&enR, RESET); // ON = RESET, motor derecho

	inR.pGPIOx									=	GPIOD;
	inR.pinConfig.GPIO_PinNumber				=	PIN_2;
	inR.pinConfig.GPIO_PinMode					=	GPIO_MODE_OUT;
	inR.pinConfig.GPIO_PinOutputType			=	GPIO_OTYPER_PUSHPULL;
	inR.pinConfig.GPIO_PinOutputSpeed			=	GPIO_OSPEEDR_MEDIUM;
	inR.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&inR);
	gpio_WritePin(&inR, SET); // SET forward// RESET backward

	enL.pGPIOx									=	GPIOC;
	enL.pinConfig.GPIO_PinNumber				=	PIN_10;
	enL.pinConfig.GPIO_PinMode					=	GPIO_MODE_OUT;
	enL.pinConfig.GPIO_PinOutputType			=	GPIO_OTYPER_PUSHPULL;
	enL.pinConfig.GPIO_PinOutputSpeed			=	GPIO_OSPEEDR_MEDIUM;
	enL.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&enL);
	gpio_WritePin(&enL, RESET); // ON = RESET, motor izquierdo

	inL.pGPIOx									=	GPIOC;
	inL.pinConfig.GPIO_PinNumber				=	PIN_12;
	inL.pinConfig.GPIO_PinMode					=	GPIO_MODE_OUT;
	inL.pinConfig.GPIO_PinOutputType			=	GPIO_OTYPER_PUSHPULL;
	inL.pinConfig.GPIO_PinOutputSpeed			=	GPIO_OSPEEDR_MEDIUM;
	inL.pinConfig.GPIO_PinPuPdControl			=	GPIO_PUPDR_NOTHING;
	gpio_Config(&inL);
	gpio_WritePin(&inL, RESET); // RESET forward// SET backward

	pwm_R.ptrTIMx				=	TIM2;
	pwm_R.config.channel		=	PWM_CHANNEL_2;
	pwm_R.config.periodo		=	1000; 	// [ms/100] {25,50,100} Hz Default = 25Hz (1kHz)
	pwm_R.config.prescaler		=	100; 	// 1us
	pwm_R.config.dutyCycle		=	400;	// [duty/1000] Default 20.0%
	pwm_R.config.outPolarity	=	PWM_POLARITY_LOW; // LOW forward // HIGH backward

	pwm_Config(&pwm_R);
	pwm_star_Signal(&pwm_R);

	pwm_L.ptrTIMx				=	TIM5;
	pwm_L.config.channel		=	PWM_CHANNEL_1;
	pwm_L.config.periodo		=	1000;	// 500Hz
	pwm_L.config.prescaler		=	100; 	// 10us
	pwm_L.config.dutyCycle		=	400;	// 20.0%
	pwm_L.config.outPolarity	=	PWM_POLARITY_HIGH; // HIGH forward // LOW backward

	pwm_Config(&pwm_L);
	pwm_star_Signal(&pwm_L);

	/* PID Controller */
	pid_Left.Kp							= 40.0f; //1.9 starts in the conversion factor from N to speed
	pid_Left.Ki							= 39.0f; //39
	pid_Left.Kd							= 0.2f; //0.2
	//	pid_Left.delta_Kp					= 5.0f;

	pid_Left.T							= SAMPLING_TIME/1000; // Sampling Time =  10ms
	pid_Left.tau						= 3.6f; //just to keep it greater than samplingTime but it can go close to zero or bigger than samplingTime
	pid_Left.limMin						= MIN_PWM;	// N min value
	pid_Left.limMax						= MAX_PWM;	// N max value


	pid_Right.Kp						= 40.0f; //2.25 starts in the conversion factor from N to speed
	pid_Right.Ki						= 40.0f; //45
	pid_Right.Kd						= 0.2f; //0.2
	//	pid_Right.delta_Kp					= 5.0f; //

	pid_Right.T							= SAMPLING_TIME/1000; // Sampling Time =  10ms
	pid_Right.tau						= TAU; //just to keep it greater than samplingTime but it can go close to zero or bigger than samplingTime
	pid_Right.limMin					= MIN_PWM+50;	// N min value
	pid_Right.limMax					= MAX_PWM+50;	// N max value

	/*
	 * configure SPI2
	 */
//	spiSlavePin.pGPIOx							= GPIOB;
//	spiSlavePin.pinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
//	spiSlavePin.pinConfig.GPIO_PinNumber		= PIN_1;
//	spiSlavePin.pinConfig.GPIO_PinOutputSpeed	= GPIO_OSPEEDR_MEDIUM;
//	spiSlavePin.pinConfig.GPIO_PinOutputType	= GPIO_OTYPER_PUSHPULL;
//	spiSlavePin.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spiSlavePin);
//	gpio_WritePin(&spiSlavePin, SET); // Starts unselected
//
//	/*config MISO*/
//	spiMISO.pGPIOx								= GPIOB; //A //B
//	spiMISO.pinConfig.GPIO_PinNumber			= PIN_14; //12 //14
//	spiMISO.pinConfig.GPIO_PinMode				= GPIO_MODE_ALTFN;
//	spiMISO.pinConfig.GPIO_PinAltFunMode		= AF5; //6 //5
//	spiMISO.pinConfig.GPIO_PinPuPdControl 		= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spiMISO);
//
//	/* config MOSI*/
//	spiMOSI.pGPIOx								= GPIOB; //B //B
//	spiMOSI.pinConfig.GPIO_PinNumber			= PIN_15; //8 //15
//	spiMOSI.pinConfig.GPIO_PinMode				= GPIO_MODE_ALTFN;
//	spiMOSI.pinConfig.GPIO_PinAltFunMode		= AF5; //6 //5
//	spiMOSI.pinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spiMOSI);
//
//	/* config SCK*/
//	spiSCK.pGPIOx								= GPIOB; //B //B
//	spiSCK.pinConfig.GPIO_PinNumber				= PIN_13; //0 //13
//	spiSCK.pinConfig.GPIO_PinMode				= GPIO_MODE_ALTFN;
//	spiSCK.pinConfig.GPIO_PinAltFunMode			= AF5; //6 //5
//	//	spiSCK.pinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spiSCK);
//
//	/* config SPIx */
//	spiTester.ptrSPIx							= SPI2; //SPI5 //SPI2
//	spiTester.SPI_slavePin						= spiSlavePin;
//
//	spiTester.SPI_Config.SPI_mode				= SPI_POL_PHA_11;
//	spiTester.SPI_Config.SPI_baudrate			= SPI_BAUDRATE_FPCLK_4; // 12.5MHz for SPI2
//	spiTester.SPI_Config.SPI_dataSize			= SPI_DATASIZE_8_BIT;
//	spiTester.SPI_Config.SPI_fullDuplexEnable	= SPI_FULL_DUPPLEX;
//	spi_config(spiTester);

	/*config data available interrupt*/
//	spi_extiPin_DataAvailable.pGPIOx						= GPIOC;
//	spi_extiPin_DataAvailable.pinConfig.GPIO_PinNumber		= PIN_4;
//	spi_extiPin_DataAvailable.pinConfig.GPIO_PinMode		= GPIO_MODE_IN;
//	spi_extiPin_DataAvailable.pinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
//	gpio_Config(&spi_extiPin_DataAvailable);
//
//	spi_DataAvailable.edgeType					= EXTI_RISING_EDGE;
//	spi_DataAvailable.pGPIOHandler				= &spi_extiPin_DataAvailable;
//	spi_DataAvailable.interruptPriority			= e_PRIORITY_NORMAL_MIN_PLUS_3;
//
//	exti_Config(&spi_DataAvailable);
//	exti_config_newInterrupt(&spi_DataAvailable, e_PRIORITY_FREERTOS_MIN_PLUS_5);


	/* Private configurations */

//	L3G4200D.FullScaleSelection					= e_2000DPS; // more range less sensibility
//	L3G4200D.HPFcutOffFreq						= e_HPF_3;  // freq greater than 4Hz
//	L3G4200D.OutputSelection					= SET;	// allows HPF and LPF2
//	L3G4200D.allowDataReady						= RESET; // data ready int
//	L3G4200D.axisToEnable						= e_EN_ONLY_Z_AXIS;
//	L3G4200D.bandwidth							= e_BW3; //cut off 110Hz
//	L3G4200D.outputDataRate						= e_ODR400;
//	L3G4200D.powerMode							= e_NORMALMODE;
//	L3G4200D.FIFOstreamEnable					= SET;
//
//	L3G4200D.ptrSensorSPI						= &spiTester;
//	L3Gyro_config(&L3G4200D);

//	switch (L3G4200D.FullScaleSelection) {
//		case e_250DPS:
//			cFactor = 8.75;
//			break;
//		case e_500DPS:
//			cFactor = 17.50;
//			break;
//		case e_2000DPS:
//			cFactor = 70.0;
//			break;
//		default:
//			cFactor = 8.75;
//			break;
//	}

}
